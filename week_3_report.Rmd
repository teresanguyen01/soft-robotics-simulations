---
title: "Week Three Report"
date: "06/02/25 - 06/06/2025"
output:
  word_document: default
  html_notebook: default
  pdf_document: default
---

## Introduction

This week’s work is primarily focusing on transferring the mocap data into angle arrays for the humanoid.xml model that we will be using and training in Genesis.  The purpose of the angle arrays is that if we can make the model move based on the angle arrays, then we can use reinforcement learning to train the model based on the behavior and the next step would be to implement the sensors into the angle array using regression and machine learning models. 

## Cleaning the Mocap Data

The first thing I did was try to understand the mocap data. I had a previous code cleaning script from the second week where all the data columns were renamed and refined that script to make it work with other mocap data. The file is called ```mocap_data_analysis.Rmd``` and it takes in the mocap data, removes the unnecessary columns and rows, and cleans up the column headers to be more understandable, and returns a csv file with ```cleaned``` at the end. 

The mocap data was cleaned based off [https://docs.optitrack.com/markersets/full-body/conventional-39](#this document). A dictionary of all the labels was made and data was cleaned based on the dictionary. Time was changed from seconds to milliseconds as well to have higher accuracy and match the sensor data. 

Some issues arose, though. For instance, there were two different types of variables for some body parts even though they were the same thing. For example, “RUArm” and “RUPA” both referred to the right upper arm, but I was not sure what to pick. Alexander Florence pointed out that the former was the rigid body so position and rotation while the latter was the position only, so it made the most sense to use the one with position and rotation. 

```{r, include=FALSE}

mocap_data_cleaned <- read.csv("/Users/teresanguyen/Documents/Faboratory Stuff/soft-robotics-simulations/data/raise_lhand_mocap_cleaned.csv")
head(mocap_data_cleaned)

```

## Building the Angle Array

The next task I worked on was building the angle array and that meant understanding the [https://github.com/google-deepmind/mujoco/blob/main/model/humanoid/humanoid.xml](#humanoid xml model). The humanoid model was developed by Google Deepmind and consists of 21 joints listed from lines 202 – 224: "abdomen_z", "abdomen_y", "abdomen_x", "hip_x_right", "hip_z_right", "hip_y_right", "knee_right", "ankle_y_right", "ankle_x_right", "hip_x_left", "hip_z_left", "hip_y_left", "knee_left", "ankle_y_left", "ankle_x_left", "shoulder1_right", "shoulder2_right", "elbow_right", "shoulder1_left", "shoulder2_left", "elbow_left".

The most important joints that we would need are the “abdomen_z”, “abdomen_y”, “abdomen_x”, “shoulder1_right”, “shoulder2_right”, “elbow_right”, “shoulder1_left”, “shoulder2_left”, “elbow_left”, torso as the root (Jue).

I first created an angle array data frame in R consisting of all the headers I wanted (the joint names) and then worked on calculating the angle for each joint. How I calculated each joint angle was based on quaternions and Euler angles. 

### Quaternions and Euler Angles

Quaternions describe 3D orientation and how the model is oriented in space. They consist of the x, y, z, and w, which are scalar values (how much the object has rotated around that vector). The unit of measurement is like Euler angles. Euler angles also demonstrate rotation, but the issue is that it is vulnerable to gimbal locks. 

Gimbal lock occurs in rotational systems and when using Euler angles to represent 3D orientation. It is the loss of one degree of freedom when certain axis alignments are reached, causing a “locking” of the system into a two-dimensional space. Although the xml only takes Euler angles for the joints, we will be using the quaternions to convert into Euler angles.

The code that I used to create the function in R to convert quaternions to Euler angles is below.

```{r}

quat_to_euler <- function(qx, qy, qz, qw) {

  # roll (x)
  sinr_cosp <- 2 * (qw * qx + qy * qz)
  cosr_cosp <- 1 - 2 * (qx^2 + qy^2)
  roll <- atan2(sinr_cosp, cosr_cosp)

  # pitch (y)
  sinp <- 2 * (qw * qy - qz * qx)
  pitch <- ifelse(abs(sinp) >= 1, sign(sinp) * pi/2, asin(sinp))

  # yaw (z)
  siny_cosp <- 2 * (qw * qz + qx * qy)
  cosy_cosp <- 1 - 2 * (qy^2 + qz^2)
  yaw <- atan2(siny_cosp, cosy_cosp)

  return(c(roll, pitch, yaw))
}

```

## Matching Angles

Afterwards, I mapped each joint to an entry from the cleaned mocap csv file. For instance, to get the joint angles for the right hip joint, I used the quaternions of the right thigh from the mocap data since the hip joint is the connection point between the legs and torso and is made up of the thigh bone and hip bone, so I used the thigh bone angles. Below shows the mappings of how the angle array was calculated for each joint. 

### Joint Angle Calculation Table

| **Joint Angle**   | **Source Segment** | **Quaternion Columns Used**                        | **Euler Axes Used** | **Notes**                             |
| ----------------- | ------------------ | -------------------------------------------------- | ------------------- | ------------------------------------- |
| `abdomen_z`       | Abdomen            | `abdomen_X`, `abdomen_Y`, `abdomen_Z`, `abdomen_W` | Z-axis              | From full Abdomen quaternion          |
| `abdomen_y`       | Abdomen            | Same as above                                      | Y-axis              |                                       |
| `abdomen_x`       | Abdomen            | Same as above                                      | X-axis              |                                       |
| `hip_x_right`     | Right Thigh        | `right_thigh_X`, `Y`, `Z`, `W`                     | X-axis              | Converted from thigh rotation         |
| `hip_z_right`     | Right Thigh        | Same as above                                      | Z-axis              |                                       |
| `hip_y_right`     | Right Thigh        | Same as above                                      | Y-axis              |                                       |
| `knee_right`      | Right Shin         | `right_shin_X`, `Y`, `Z`, `W`                      | X-axis only         | Only flexion/extension kept           |
| `ankle_y_right`   | Right Foot         | `right_foot_X`, `Y`, `Z`, `W`                      | Y-axis              | Inversion/eversion                    |
| `ankle_x_right`   | Right Foot         | Same as above                                      | X-axis              | Plantar/dorsiflexion                  |
| `hip_x_left`      | Left Thigh         | `left_thigh_X`, `Y`, `Z`, `W`                      | X-axis              | Euler columns named `[rad]` initially |
| `hip_z_left`      | Left Thigh         | Same as above                                      | Z-axis              |                                       |
| `hip_y_left`      | Same               | Same                                               | Y-axis              |                                       |
| `knee_left`       | Left Shin          | `left_shin_X`, `Y`, `Z`, `W`                       | X-axis only         | Same logic as right knee              |
| `ankle_y_left`    | Left Foot          | `left_foot_X`, `Y`, `Z`, `W`                       | Y-axis              |                                       |
| `ankle_x_left`    | Same               | Same                                               | X-axis              |                                       |
| `shoulder1_right` | Right Upper Arm    | `right_upper_arm_X`, `Y`, `Z`, `W`                 | Y-axis              | Based on upper arm orientation (Y)    |
| `shoulder2_right` | Right Upper Arm    | Same                                               | X-axis              |                                       |
| `elbow_right`     | Right Forearm      | `right_forearm_X`, `Y`, `Z`, `W`                   | X-axis              | Only flexion/extension captured       |
| `shoulder1_left`  | Left Upper Arm     | `left_upper_arm_X`, `Y`, `Z`, `W`                  | Y-axis              | Based on upper arm quaternion         |
| `shoulder2_left`  | Same               | Same                                               | X-axis              |                                       |
| `elbow_left`      | Left Forearm       | `left_forearm_X`, `Y`, `Z`, `W`                    | X-axis              |                                       |

## Transferring Angle Array to Genesis

I then made a Python script to read in the angle array into genesis. I used ```pandas``` to read in the data set and created a loop to set the position of the robot using ```set_qos```. Then I made a step of the scene and made the program sleep for around 0.005 of a second to stimulate the movement of frames. I was surprised to see that when I added the x, y, z, qx, qy, qz, qw coordinates, it made the robot out of view, which is when I realized that the variable name of ```Skeleton.002.Skeleton.002``` was not the base position of the model. I ended up setting the position to ```0, 0, 1``` to override my base positions and it worked from there.

The robot was not moving as I expected. For instance, when running the right hand angle array, the robot was moving its knees and left hand, which is not what I expected.

```[pictures and videos will be taken later]```

To ensure my angle array was correct, I did created some graphs to determine if the behavior was expected. 

### Right Hand x3

#### Elbows and Shoulders

```{r, include=FALSE}

library(ggplot2)
library(readr)

angle_array <- read.csv("~/Documents/Faboratory Stuff/soft-robotics-simulations/data/angle_array_rhand_mocap.csv")

ggplot(angle_array, aes(x = time_ms)) +
  geom_line(aes(y = shoulder1_right, color = "shoulder1_right")) +
  geom_line(aes(y = shoulder2_right, color = "shoulder2_right")) +
  labs(title = "Right Shoulder Joint Angles Over Time", x = "Time (ms)", y = "Angle (rad)") +
  scale_color_manual(values = c("shoulder1_right" = "blue", "shoulder2_right" = "red")) +
  theme_minimal()

library(tidyr)

elbow_data <- angle_array %>%
  pivot_longer(
    cols = c(elbow_right, elbow_left),
    names_to = "joint",
    values_to = "angle"
  )


ggplot(elbow_data, aes(x = time_ms, y = angle, color = joint)) +
  geom_line() +
  labs(
    title = "Elbow Joint Angles Over Time",
    x = "Time (ms)",
    y = "Angle (rad)"
  ) +
  theme_minimal()

```

In expected to see 3 peaks in the shoulders and elbows since the original motion was moving the right arm 3 times. Shoulder1_right is based off of the y-axis so I expected it to have the peaks and the data showed there were three peaks from 0.4 radians (22 degrees) to 0.9 radians (52 degrees). Elbow right also had peaks (around 3 radians = 172 degrees) elbow left stayed stagnant which is also what I expected.

#### Right and Left Knees

```{r}

ggplot(angle_array, aes(x = time_ms)) +
  geom_line(aes(y = knee_right, color = "knee_right")) +
  geom_line(aes(y = knee_left, color = "knee_left")) +
  labs(title = "Knee Angles over time", x = "Time (ms)", y = "Angle (rad)") +
  scale_color_manual(values = c("knee_right" = "blue", "knee_left" = "red")) +
  theme_minimal()

```

The knees showed very little fluctuation so I assumed there would not be too much movement with them. In the Genesis model, there was a lot of movement, so I have to investigate what the issue is there. These graphs prove that the angle array was correct. A normal knee degree angle is 13-18 degrees [https://www.physio-pedia.com/Q_Angle](#humanoid xml model). 

To ensure validity, I also made graphs of the left hand moving three times. 

### Left Hand x3

#### Elbows and Shoulders

```{r, include = FALSE}

angle_array <- read.csv("~/Documents/Faboratory Stuff/soft-robotics-simulations/data/angle_array_lhand_mocap.csv")

ggplot(angle_array, aes(x = time_ms)) +
  geom_line(aes(y = elbow_right, color = "elbow_right")) +
  geom_line(aes(y = elbow_left, color = "elbow_left")) +
  labs(title = "Elbow Right & Left Angles over time", x = "Time (ms)", y = "Angle (rad)") +
  scale_color_manual(values = c("elbow_right" = "blue", "elbow_left" = "red")) +
  theme_minimal()

```

These results matched my predictions.

## Next Steps

Currently, I am trying to figure out the issue of what is happening in Genesis and if there is an issue with my angle arrays. Next week, I will ask Alexander about the base position angles from the mocap data and integrate the sensor data into the angle arrays.

### Misc. Work

I tried to run Genesis on my computer and finally found a solution that (kind of) works. The directions are below: 

```
curl https://repo.anaconda.com/miniconda/Miniconda3-latest-MacOSX-arm64.sh -o miniconda.sh
bash miniconda.sh -b -u -p miniconda # installs to current folder in a `miniconda` subfolder
. miniconda/bin/activate

conda create -n genesis python=3.12
conda activate genesis
pip install genesis-world
pip install torch
```

However, mac books are still too slow to run the simulation so it ends up crashing when you click on the pop-up, so the simulations have to be run on the super computer. 

Additionally, I tried Google Colab pro and running Genesis on a Nvidia GPU, but it crashes my computer.
